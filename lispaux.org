# # -*- org-confirm-babel-evaluate: t -*-
#+TITLE: \zwnj^{147}Pm Lisp
#+AUTHOR: 147Pm
#+EMAIL: borgauf@sdf.org
#+DATE: 2017-11-29T11:20:22
#+FILETAGS: :lispaux:
#+LANGUAGE:  en
# #+INFOJS_OPT: view:showall ltoc:t mouse:underline path:http://orgmode.org/org-info.js
#+HTML_HEAD: <link rel="stylesheet" href="../data/stylesheet.css" type="text/css">
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:10 num:4 toc:nil \n:nil @:t ::t |:t _:{} *:t ^:{} prop:t
#+OPTIONS: prop:t
# This makes MathJax not work
# #+OPTIONS: tex:imagemagick
# this makes MathJax work
#+OPTIONS: tex:t
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [american]
# Setup tikz package for both LaTeX and HTML export:
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{commath}
#+LaTeX_HEADER: \usepackage{pgfplots}
#+LaTeX_HEADER: \usepackage{sansmath}
#+LaTeX_HEADER: \usepackage{mathtools}
# #+HTML_MATHJAX: align: left indent: 5em tagside: left font: Neo-Euler
#+PROPERTY: header-args:latex+ :packages '(("" "tikz"))
#
#+PROPERTY: header-args:latex+ :imagemagick (by-backend (latex nil) (t "yes"))
#+PROPERTY: header-args:latex+ :exports results :fit yes
#
#+STARTUP: showall
#+STARTUP: align
#+STARTUP: indent
#+STARTUP: entitiespretty
#+STARTUP: logdrawer

* LISP AUXILIARY

\rightarrow 2017-11-29T10:44:48 details of Wason deck

~flet~ example from [[http://jtra.cz/stuff/lisp/sclr/flet.html][Jakub Trávník]]:

#+begin_src lisp :results silent
(flet ((sin2x (x) (sin (* 2 x)))
       (cos2x (x) (cos (* 2 x))))
  (+ (sin2x 0.2) (cos2x 0.2)))
#+end_src

~swap~ and ~shuffle~ are embedded in ~wason-deck~. ~shuffle~ uses a random number generator to 

#+begin_src lisp :results silent
(defun swap (lst el1 el2)
  "in lst swap indices el1 and el2 in place (~elt~ similar to ~nth~)"
  (let ((tmp (elt lst el1)))
    (setf (elt lst el1) (elt lst el2))
    (setf (elt lst el2) tmp)))
#+end_src

#+begin_src lisp :results silent
(defun shuffle (lst)
  "Shuffle the elements in lst.
shuffling is done in place."
  (loop for i in (reverse (range (length lst) :min 1))
     do (let ((j (random (+ i 1))))
          (swap lst i j)))
  lst)
#+end_src

A sequence generator in the [[http://kitchingroup.cheme.cmu.edu/blog/2014/09/06/Randomize-a-list-in-Emacs/][original]] ~shuffle~ code used elisp's  ~number-sequence~. We replace with [[https://stackoverflow.com/questions/13937520/pythons-range-analog-in-common-lisp][this]] ~range~:

#+begin_src lisp :results silent
(defun range (max &key (min 0) (step 1))
  (loop for n from min below max by step
     collect n))
#+end_src

My Wason card tricks:

#+begin_src lisp :results silent
(defun wason-deck ()
  "This `consolst` and `vowlist` building is unnecessary, but a good exercise"
  (let* ((alphab '(a b c d e f g h i j k l m n o p q r s t u v w x y z))
         (consonents '(b c d f g h j k l m n p q r s t v w x y z))
         (consolst (remove 'NIL (mapcar (lambda (x) (find x consonents)) alphab)))
         (vowlst (remove 'NIL (mapcar (lambda (x) (find x '(a e i o))) alphab))))

    (labels ((make-consodeck ()
                           (mapcar (lambda (x) (let ((num (random 54)))
                                                 (cons x (if (evenp num)
                                                             (1+ num)
                                                           num)))) consolst))
           (make-voweldeck () 
                           (mapcar (lambda (x) (let ((num (random 54)))
                                                 (cons x (if (oddp num)
                                                             (1+ num)
                                                           num)))) vowlst))
           (swap (slst el1 el2)
                 (let  ((tmp (elt slst el1)))
                   (setf (elt slst el1) (elt slst el2))
                   (setf (elt slst el2) tmp)))

           (shuffle (slst)
                    (loop for i in (reverse (range (length slst) :min 1))
                          do (let ((j (random (+ i 1))))
                               (swap slst i j)))
                    slst)
           (flip (flst)
                 (mapcar (lambda (x) (let ((num (random 2)))
                                       (if (zerop num)
                                           (cons (cdr x) (car x))
                                         x))) flst)))
           (flip (shuffle (append (make-consodeck) (make-voweldeck)))))))
#+end_src

#+begin_src lisp :results silent
(defun wason-deck2 (&optional (p 0))
  (let* ((consonents '(b c d f g h j k l m n p q r s t v w x y z))
         (vowels '(a e i o u))
         (conso-deck (mapcar (lambda (x)
                               (cons x (1+ (* 2 (random 27)))))
                             consonents))
         (vowel-deck (mapcar (lambda (x)
                               (cons x (* 2 (random 27))))
                             vowels))
         (wdeck '()))

    (labels ((swap (slst el1 el2)
               (let  ((tmp (elt slst el1)))
                 (setf (elt slst el1) (elt slst el2))
                 (setf (elt slst el2) tmp)))

             (shuffle (slst)
               (loop for i :from (1- (length slst)) :downto 1
                  do (let ((j (random (+ i 1))))
                       (swap slst i j)))
               slst)

             (flip (flst)
               (mapcar (lambda (x) (let ((num (random 2)))
                                     (if (zerop num)
                                         (cons (cdr x) (car x))
                                         x))) flst)))

      (setf wdeck (flip (shuffle (append conso-deck vowel-deck)))))
    
    (if (zerop p) wdeck
        (mapcar (lambda (x) (let ((num (random 6)))
                              (cond ((and (zerop num) (numberp (car x))) (cons (1+ (car x)) (cdr x)))
                                    ((and (zerop num) (numberp (cdr x))) (cons (car x) (1+ (cdr x))))
                                    (t x)))) wdeck))))
#+end_src

#+begin_src lisp :results silent
(defun wason-deck3 (&optional (p 0))
  (let* ((consonents '(b c d f g h j k l m n p q r s t v w x y z))
         (vowels '(a e i o u))
         (conso-deck (mapcar (lambda (x)
                               (cons x (1+ (* 2 (random 27)))))
                             consonents))
         (vowel-deck (mapcar (lambda (x)
                               (cons x (* 2 (random 27))))
                             vowels))
         (wdeck '()))
    (labels
        ((shuffle (slst)
           (loop :for i :from (1- (length slst)) :downto 1
              :do (rotatef (nth i slst)
                           (nth (random (1+ i)) slst)))
                           slst)
         
         (flip (flst)
           (mapcar (lambda (x) (let ((num (random 2)))
                                 (if (zerop num)
                                     (cons (cdr x) (car x))
                                     x))) flst)))

      (setf wdeck (flip (shuffle (append conso-deck vowel-deck)))))
    
    (if (zerop p) wdeck
        (mapcar (lambda (x) (let ((num (random 6)))
                              (cond ((and (zerop num) (numberp (car x))) (cons (1+ (car x)) (cdr x)))
                                    ((and (zerop num) (numberp (cdr x))) (cons (car x) (1+ (cdr x))))
                                    (t x)))) wdeck))))
#+end_src

#+begin_src lisp :results silent
(defun wason-deck4 (&optional (p 0))
  (labels
      ((shuffle (slst)
         (loop :for i :from (1- (length slst)) :downto 1
            :do (rotatef (nth i slst)
                         (nth (random (1+ i)) slst)))
         slst)
       
       (flip (flst)
         (mapcar (lambda (x) (let ((num (random 2)))
                               (if (zerop num)
                                   (cons (cdr x) (car x))
                                   x))) flst)))
    (let* ((consonents '(b c d f g h j k l m n p q r s t v w x y z))
           (vowels '(a e i o u))
           (conso-deck (mapcar (lambda (x)
                                 (cons x (1+ (* 2 (random 27)))))
                               consonents))
           (vowel-deck (mapcar (lambda (x)
                                 (cons x (* 2 (random 27))))
                               vowels))
           (wdeck (flip (shuffle (append conso-deck vowel-deck)))))
      
      (if (zerop p) wdeck
          (mapcar (lambda (x) (let ((num (random 6)))
                                (cond ((and (zerop num) (numberp (car x))) (cons (1+ (car x)) (cdr x)))
                                      ((and (zerop num) (numberp (cdr x))) (cons (car x) (1+ (cdr x))))
                                      (t x)))) wdeck)))))
#+end_src



#+begin_src lisp :results silent
(defun myshuffle (slst)
         (loop :for i :from (1- (length slst)) :downto 1
            :do (rotatef (nth i slst)
                         (nth (random (1+ i)) slst))))
#+end_src

#+name:practice
#+begin_src lisp :results silent
(defun cxr-symbol-to-cxr-list (s)
  (labels ((collect (l)
             (if l
                 (list*
                  1
                  (if (char= (car l) #\A)
                      'A
                      'D)
                  (collect (cdr l))))))
    (collect
        (cdr       ; chop off C
         (butlast ; chop off R
          (coerce
           (symbol-name s)
           'list))))))
#+end_src

#+name:practice
#+begin_src lisp :results silent
(labels
    ((shuffle …)
     (flip …))
  (let ((consonants …) … (wdeck (flip (…))))))
#+end_src

#+begin_src lisp
(defun collect-leaves (tree)
  (let ((leaves ()))
    (labels ((walk (tree)
               (cond
                 ((null tree))
                 ((atom tree) (push tree leaves))
                 (t (walk (car tree))
                    (walk (cdr tree))))))
      (walk tree))
    (nreverse leaves)))
#+end_src

\rightarrow 2017-11-30T15:30:04 ~flet~ and ~labels~

Before, ~wason-deck used ~flet~, however, ~swap~ had been defined and evaluated outside, hence, ~flet~ worked. However, ~flet~ does not allow referencing of one internal function by another. This means we had to switch to ~labels~.


Below is a good way (non-destructive) to flip the dotted pair atoms, which we used in ~wason-deck~ above:

#+begin_src lisp :results raw
(mapcar (lambda (pair)
                       (if (= (random 2) 0)
                           (cons (cdr pair)
                                 (car pair))
                         pair))
                     '((B . 21) (O . 24) (P . 15) (R . 47) (K . 49)))
#+end_src

Now we need to randomly "flip" the cards, which means reverse the atoms in the dotted pairs.




